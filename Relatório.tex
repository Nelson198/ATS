% Setup -------------------------------

\documentclass[a4paper]{report}
\usepackage[a4paper, total={6in, 10in}]{geometry}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\usepackage{hyperref}
\usepackage{tabularx}
\usepackage{booktabs}

% Encoding
%--------------------------------------
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
%--------------------------------------

% Portuguese-specific commands
%--------------------------------------
\usepackage[portuguese]{babel}
%--------------------------------------

% Hyphenation rules and references
%--------------------------------------
\usepackage{hyphenat}
\usepackage{hyperref}
%--------------------------------------

% Capa do relatório

\title{
    Análise e Teste de Software
    \\ \Large{\textbf{Trabalho Prático}}
    \\ -
    \\ Mestrado em Engenharia Informática
    \\ \large{Universidade do Minho}
    \\ Relatório
}
\author{
    \begin{tabular}{ll}
        \textbf{Grupo nº3}
        \\\hline
        PG41091 & Nelson José Dias Teixeira
        \\
        PG41081 & José Alberto Martins Boticas
        \\
        PG41094 & Pedro Rafael Paiva Moura
        \\
        A80499  & Moisés Manuel Borba Roriz Ramires
    \end{tabular}
}

\date{\today}

\begin{document}

\begin{titlepage}
    \maketitle
\end{titlepage}

% Resumo

\begin{abstract}
    No ano lectivo 2018/2019, no contexto da disciplina de Programação Orientada a Objectos
    (POO) leccionada no Departamento de Informática da Universidade do Minho, os alunos
    tiveram de desenvolver em grupo uma aplicação Java, denominada por  \textit{UmCarroJá}, para gerir um serviço de aluguer de
    veículos particulares pela internet.\,\,No contexto da disciplina de Análise e Teste de Software (ATS) pretende-se que neste projeto se apliquem técnicas de análise e teste de software, estudadas nas aulas, de modo a analisar a qualidade de duas das soluções desenvolvidas pelos alunos de POO.
\end{abstract}

% Índice

\tableofcontents

% Introdução

\chapter{Introdução} \label{intro}
\large{
    Neste projeto foi-nos proposto a realização de várias tarefas de forma a analisar a qualidade das duas soluções desenvolvidas pelos alunos de POO no ano lectivo de 2018/2019. Entre estas tarefas destacam-se as seguintes:
    \begin{enumerate}
        \item Analisar a qualidade do código fonte dos sistemas de \textit{software}. Nesta análise identificam-se \textit{bad smells} no código fonte e o seu \textit{technical debt};
        \item Aplicar \textit{refactorings} de modo a eliminar os \textit{bad smells} encontrados e deste modo reduzir (se possível eliminar) o \textit{technical debt};
        \item Testar o \textit{software} de modo a ter mais garantias que ele cumpre os requisitos do enunciado da aplicação \textit{UmCarroJá};
        \item Gerar \textit{inputs} aleatórios para a aplicação \textit{UmCarroJá} que simulem execuções reais (tal como foi fornecido em POO);
        \item Analisar a performance (tempo de execução e consumo de energia) das versões iniciais do \textit{software} (i.e., com \textit{smells}) e as obtidas depois de eliminados os \textit{smells}.
    \end{enumerate}
    Os cinco pontos mencionados acima foram agrupados em quatro tarefas finais, cada uma das quais com uma percentagem na avaliação final do trabalho prático. As abordagens tomadas pelo grupo sobre cada uma destas tarefas serão expostas nos capítulos seguintes deste relatório.
    De salientar que também existem tarefas extras que complementam cada uma das tarefas referidas anteriormente.
}

\chapter{Análise e Especificação}
\section{Tarefa 1 - Qualidade do código fonte}
Nesta etapa, tal como o nome indica, será feita a análise da qualidade do código fonte da aplicação \textit{UmCarroJá} desenvolvido pelos alunos de POO. Como tal, através da ferramenta \underline{\textit{Sonarqube}}, serão indicados o número de erros no código (\textit{bugs}), vulnerabilidades, \textit{code smells} e o respetivo \textit{technical debt}. Para além destas, existe uma \textbf{tarefa extra} que consiste em definir regras adicionais na ferramenta \textit{Sonarqube} para encontrar \textit{red smells} (ou qualquer outro \textit{smell} não suportado pelo mesmo) na aplicação desenvolvida.

\subsection{Versão 1 - \textit{demo1}}
Na primeira versão desenvolvida pelos alunos de POO, \textit{demo1}, foi possível observar alguns erros no código fonte e bastantes \textit{code smells}. Apresenta-se de seguida, por categorias, a análise qualitativa desta mesma implementação.

\subsubsection{Fiabilidade}
Nesta secção da análise qualitativa da aplicação desenvolvida observam-se e identificam-se unicamente os erros (\textit{bugs}) presentes no código fonte.
Como tal, após verificar a informação existente na ferramenta \textit{Sonarqube}, os elementos deste grupo depararam-se, essencialmente, com quatro tipos de erros. Entre eles destacam-se:

\begin{enumerate}
    \item a implementação do método \textit{equals()} numa determinada classe sobrepõe a predefinida, pelo que também deve ser codificado o método \textit{hashCode()};
    \item o método \textit{equals()} presente numa determinada classe necessita de ser sobreposto à implementação predefinida ou, simplesmente, renomeado;
    \item o objeto \textit{Random} presente numa determinada classe deve ser reutilizado;
    \item o objeto \textit{ObjectOutputStream} deve ser fechado através de uma clausula \textit{try-catch-finally}.
\end{enumerate}

Na totalidade existem cerca de \textbf{14 erros} no código fonte. Quanto à severidade destes erros, existem 2 de tipo \textit{blocker}, 2 de tipo \textit{critical}, 1 de tipo \textit{major} e 9 de tipo \textit{minor}.
\par De salientar que, apesar da existência de alguns erros presentes nesta implementação, estes são facilmente corrigíveis.

\subsubsection{Segurança}
Ao nível da segurança, esta implementação apresenta apenas \textbf{uma vulnerabilidade} cujo grau de severidade é do tipo \textit{minor}. A ferramenta \textit{Sonarqube}, por forma a eliminar esta mesma, sugere encapsular a amostragem de um determinado erro através de um objeto \textit{LOGGER}. Dado que existe uma e uma só vulnerabilidade deste tipo, o \textit{software} \textit{Sonarqube} atribui nota \textit{B} a este contexto. De notar também que existem 22 casos no código fonte que precisam de ser revistos por forma a verificar se existem ou não ainda mais vulnerabilidades.

\subsubsection{Manutenção}
Neste segmento do relatório, observam-se e identificam-se os \textit{code smells}. Estes inferem o grau de interpretabilidade do código fonte e, por isso, permitem avaliar se é ou não possível evoluir a versão atual do programa desenvolvido.

Neste caso, foi possível verificar a existência de \textbf{131 \textit{code smells}}. Apresentam-se de seguida o grau de severidade de cada um destes:
\begin{itemize}
    \item \textbf{\textit{minor}}: 60 ocorrências;
    \item \textbf{\textit{major}}: 24 ocorrências;
    \item \textbf{\textit{critical}}: 41 ocorrências;
    \item \textbf{\textit{blocker}}: 6 ocorrências.
\end{itemize}

Como se pode constatar, cerca de 54\% dos \textit{code smells} possuem uma gravidade considerável, pelo que se pode inferir que esta implementação levará, potencialmente, a uma interpretabilidade razoável por parte do programador.

Segundo a ferramenta \textit{SonarQube}, demoraria cerca de 2 dias e 5 horas a corrigir todos estes "defeitos". Este facto traduz aquilo a que chamamos o \textit{technical debt}, isto é, a probabilidade de ocorrências de erros no futuro. Esta ferramenta atribui a nota \textit{A} no que diz respeito ao \textit{technical debt}.

\subsubsection{Cobertura}
Quanto à cobertura não foram testados nenhuns aspetos intrínsecos a esta implementação.

\subsubsection{Duplicação de código}
No que diz respeito à duplicação de código existem cerca de 2 blocos repetidos numa das classes implementadas, representando apenas 1\% do código total.

\subsection{Versão 2 - \textit{demo2}}
Na segunda versão desenvolvida pelos alunos de POO, \textit{demo2}, foi possível observar bastantes erros no código fonte e muitos \textit{code smells}. Apresenta-se de seguida, por categorias, a análise qualitativa desta mesma implementação.

\subsubsection{Fiabilidade}
Nesta secção da análise qualitativa da aplicação desenvolvida observam-se e identificam-se unicamente os erros (bugs) presentes no código fonte.

Após consultar a informação presente na ferramenta \textit{Sonarqube}, foi possível verificar que, no total, existem \textbf{33 \textit{bugs}} nesta implementação, sendo que 27 são do tipo \textit{minor}, 2 são do tipo \textit{major} e 4 são do tipo \textit{blocker}.

Todos estes erros estão contidos em 6 categorias. Apresenta-se de seguida não só estas últimas como também o respetivo número de erros associados à mesma:
\begin{enumerate}
    \item a implementação do método \textit{equals()} numa determinada classe sobrepõe a predefinida, pelo que também deve ser codificado o método \textit{hashCode()} (10 ocorrências);
    \item \textit{boxing} e \textit{unboxing} de objetos não devem ser imediatamente revertidos (10 ocorrências);
    \item necessidade de realizar \textit{cast} a um dos operandos na operação de divisão (7 ocorrências);
    \item objetos do tipo \textit{ObjectInputStream}, \textit{ObjectOutputStream}, \textit{FileInputStream} e \textit{BufferedReader} devem ser fechados através de uma clausula \textit{try-catch-finally} (4 ocorrências);
    \item objetos do tipo \textit{Calendar} não devem conter a referência \textit{static} e, como tal, devem ser instanciados (1 ocorrência);
    \item a exceção \textit{NullPointerException} pode ser lançada e, como tal, deve ser utilizada a cláusula \textit{try-catch} para prevenir a referência a um apontador nulo (1 ocorrência).
\end{enumerate}

\par De salientar que, apesar da existência de vários erros nesta implementação, estes são corrigíveis.

\subsubsection{Segurança}
Ao nível da segurança, esta implementação apresenta \textbf{10 vulnerabilidades} cujo grau de severidade é do tipo \textit{minor}. Consequentemente, a ferramenta \textit{Sonarqube} atribui nota \textit{B} a este contexto, dado que existe pelo menos uma vulnerabilidade do tipo \textit{minor}. Todas estas vulnerabilidades baseiam-se, de forma global, na transformação de variáveis em constantes. De notar também que existem 16 casos no código fonte que precisam de ser revistos por forma a verificar se existem ou não ainda mais vulnerabilidades.

\subsubsection{Manutenção}
Neste parte do presente documento, observam-se e identificam-se os \textit{code smells}. Estes inferem o grau de interpretabilidade do código fonte e, por isso, permitem avaliar se é ou não possível evoluir a versão atual do programa desenvolvido.

Neste caso, foi possível verificar a existência de \textbf{330 \textit{code smells}}. Apresentam-se de seguida o grau de severidade de cada um destes:
\begin{itemize}
    \item \textbf{\textit{info}}: 1 ocorrência (apenas faz-se referência à presença de um comentário \textit{TODO});
    \item \textbf{\textit{minor}}: 182 ocorrências;
    \item \textbf{\textit{major}}: 87 ocorrências;
    \item \textbf{\textit{critical}}: 50 ocorrências;
    \item \textbf{\textit{blocker}}: 10 ocorrências.
\end{itemize}

Comparativamente à versão número um, esta implementação possui, aproximadamente, 2,5 vezes mais \textit{code smells}, o que leva a concluir que esta, potencialmente, levará a uma interpretabilidade bastante pior.

Segundo a ferramenta \textit{SonarQube}, demoraria cerca de 6 dias a corrigir todos estes "defeitos". Este facto traduz aquilo a que chamamos o \textit{technical debt}, isto é, a probabilidade de ocorrências de erros no futuro. Esta ferramenta atribui a nota \textit{A} no que diz respeito ao \textit{technical debt}.

\subsubsection{Cobertura}
Quanto à cobertura não foram testados nenhuns aspetos intrínsecos a esta implementação.

\subsubsection{Duplicação de código}
No que diz respeito à duplicação de código existem 23 blocos repetidos em duas das classes implementadas, representando apenas 3,7\% do código total.

\subsection{Tarefa extra}
Quanto à realização desta tarefa, após dialogar com os docentes desta unidade curricular, optou-se por dar prioridade à segunda e última tarefa extra deste projeto. 
Esta supremacia surge pelos simples facto de a adição de novas regras à ferramenta \textit{SonarQube} ser impraticável. Isto é, quando as novas regras são geradas, é criado um novo ficheiro \textit{jar} com a informação respetiva. Posteriormente, este é incorporado na ferramenta \textit{SonarQube}, dentro da pasta \textit{extensions/plugins}, tal como é sugerido no tutorial indicado nos \textit{slides} dos docentes.
Ao arrancar o software \textit{SonarQube}, este acaba por colapsar ou terminar abruptamente sem indicar qualquer tipo de erro. Desta forma, tal como já tinhamos indicado juntos dos docentes, fica aqui explícito a razão pela qual a execução desta tarefa extra fica incompleta.

\section{Tarefa 2 - \textit{Refactoring}}
Nesta tarefa são utilizadas ferramentas como o \textit{autorefactor}, \textit{IDEs} do \textit{Java} que suportam \textit{refactoring}, ou o \textit{jStanley} para identificar e eliminar os \textit{bad smells} e \textit{red smells} existentes no \textit{software} fornecido. É também apresentado um estudo detalhado sobre os \textit{smells} encontrados nas aplicações fornecidas, os \textit{refactorings} 
aplicados e o \textit{technical debt}.

\subsection{Versão 1 - \textit{demo1}}
Como foi referido anteriormente na secção 2.1.1, nesta versão foram observados vários problemas no código fonte.\\
Estes problemas estão divididos pelos seguintes tipos: \textit{Bug}, \textit{Vulnerability} e \textit{Code Smells}.\\\\
\underline{\textbf{Bugs}}
\begin{itemize}
    \item \textit{\textbf{blocker}}\\
        Foi observado o seguinte \textit{blocker bug}:\\
        \textbf{Use try-with-resources or close this "ObjectOutputStream" in a "finally" clause.}\\
        
        A classe \texttt{ObjectOutputStream} implementa a interface \texttt{AutoCloseable}, o que significa que é necessário fechá-la depois de a usar. Para isto, é recomendado que o objeto seja criado usando o padrão "\textit{try-with-resources}", pois vai ser fechado automaticamente.
        
        O \textit{IntelliJ} tem este refactoring implementado, logo a correção deste \textit{bug} é automática.

    
    \item \textit{\textbf{critical}}\\
        Foi observado o seguinte \textit{critical bug}:\\
        \textbf{Save and re-use this "Random".}\\
        
        Criar um objeto \texttt{Random} novo sempre que é necessário um valor aleatório é ineficiente e pode produzir números que não sejam completamente aleatórios. Para uma melhor eficiência e aleatoriedade, é preferível criar um único objeto \texttt{Random}, guardá-lo e reutilizá-lo.
        
        No \textit{Intellij}, podemos tranformar uma variável local numa variável de instância através do refactoring "\textit{Introduce Field...}", e de seguida, podemos usar o refactoring "\textit{move assignment to field declaration}".
        
        
    \item \textit{\textbf{major}}\\
        Foi observado o seguinte \textit{major bug}:\\
        \textbf{Either override Object.equals(Object), or rename the method to prevent any confusion.}\\
        
        O nome de método \texttt{equals} deveria ser usado exclusivamente para sobrepor \texttt{Object.equals(Object)}.
        
        Usando o refactoring "\textit{Rename}" do \textit{IntelliJ} facilmente resolvemos este problema alterando o nome do método.
        
        
    \item \textit{\textbf{minor}}\\
        Foi observado o seguinte \textit{minor bug}:\\
        \textbf{This class overrides "equals()" and should therefore also override "hashCode()".}\\
        
        Se dois objetos são iguais de acordo com o método \texttt{equals(Object)}, então chamar o método \texttt{hashCode()} em ambos os objetos deve produzir resultados iguais.
        Para isto acontecer, ambos os métodos devem ser herdados ou sobrepostos.
        
        Para resolver este problema, o programador apenas necessita de escrever o nome do método \texttt{hashCode} e o \textit{IntelliJ} faz \textit{autocomplete} ao método.
\end{itemize}

\underline{\textbf{Vulnerability}}
\begin{itemize}
    \item \textit{\textbf{minor}}\\
    \textbf{Use a logger to log this exception.}
    
    É recomendado a utilização de \textit{Loggers} para imprimir objetos da classe \texttt{Throwable}, pois estes normalmente contêm informação sensível que pode ser exposta.
    
    Nesta situação, o utilizador tem de fazer o refactoring manualmente, criando o \texttt{Logger} como uma variável estática da classe, e utilizando o método \texttt{log} para escrever a exceção num ficheiro \textit{log}.\\
\end{itemize}

\underline{\textbf{Code Smells}}
\begin{itemize}
    \item \textit{\textbf{Blocker}}\\
    \textbf{Remove this "clone" implementation; use a copy constructor or copy factory instead.}
    
    Acho que este não faz sentido mudar, porque eles utilizam estes métodos em streams\\
    
    \item \textit{\textbf{Critical}}\\
    \textbf{Refactor this method to reduce its Cognitive Complexity from 112 to the 15 allowed.}
    
    Complexidade cognitiva é uma medida de dificuldade sobre o entendimento/compreensão do código. Maior complexidade cognitiva significa que muito provavelmente o programador irá ter uma maior dificuldade na manutenção do seu código.
    
    Neste caso, a maior parte complexidade cognitiva resulta da excessiva existência de cláusulas \textit{"catch"}.
    
    Uma solução para este problema utilizando o refactoring do \textit{IntelliJ}, é extrair estas partes do código para novos métodos.\\
    
    
    \textbf{Define a constant instead of duplicating this literal "Parametros Inválidos" 3 times.}

    Duplicar \textit{strings} literais dificultam o processo de refactoring, pois é necessário ter o cuidado de atualizar todas as ocorrências da \textit{string} em causa.
    Por outro lado, constantes podem ser utilizadas em vários sítios, mas só precisam de ser atualizadas num único sítio.

    Com o \textit{IntelliJ}, é possível utilizar o refactoring "\textit{Introduce Constant...}", que cria uma constante com a \textit{string} selecionada, e automaticamente substitui todos os usos deste literal pela constante criada.\\

    \textbf{Add a default case to this switch.}

    Adicionar um caso \textit{default} é programação defensiva e diminui a probabilidade do programa crachar.

    O \textit{IntelliJ} permite fazer isto automaticamente, basta selecionar a cláusula \textit{switch} e carregar na opção "\textit{Insert 'default' branch}".\\
    
    \textbf{Rename this constant name to match the regular expression '\^[A-Z][A-Z0-9]*(\_[A-Z0-9]+)*\$'.}

    Convenções de código é algo que permite uma colaboração mais eficiente entre equipas e programadores. Esta regra diz que os nomes das constantes devem seguir aquela expressão regular.
    
    No \textit{IntelliJ}, basta fazer "\textit{Rename}" à variável, e este substitui logo todas as ocorrências desta variável no projeto.\\
    
    \textbf{Make the enclosing method "static" or remove this set.}
    
    Não é recomendável uma variável estática ser modificada por um método não estático.
    
    Com o \textit{IntelliJ}, é possível transformar um método não estático num método estático com o refactoring "\textit{Make Static}".\\
    
    \item \textit{\textbf{Major}}\\
    \textbf{2 duplicated blocks of code must be removed.} 
    
    Este \textit{code smell} é difícil de resolver, porque, por vezes, é complicado identificar os blocos de código duplicados.
    E se os mesmos forem identificados, pode ser difícil solucionar o problema.
    
    Uma possível solução poderá ser a criação de um método genérico que possibilite replicar o código. \\
    
    \textbf{Either remove or fill this block of code.}
    
    A maior parte das vezes que um bloco de código se encontra vazio é porque, de facto, existe código em falta.
    
    Nestes casos, programador deve remover ou preencher o bloco de código manualmente.\\
    
    
    \textbf{Rename this class to remove "Exception" or correct its inheritance.}
    
    Classes que contêm no nome a palavra \textit{Exception} devem estender a classe \texttt{Exception}.
    
    Para resolver este problema no \textit{IntelliJ}, basta aplicar um "\textit{Rename...}".\\
    
    \textbf{Constructor has 9 parameters, which is greater than 7 authorized.}
    
    Idealmente, um método não deve ter tantos parâmetros.
    Neste caso, decidimos não fazer \textit{refactoring} pois implica a alteração de muito código.\\
    
    \textbf{Extract this nested try block into a separate method.}
    
    Blocos "\textit{try/catch}" não devem ser colocados dentro de outros blocos "\textit{try/catch}". A legibilidade do código é afetada severamente porque é difícil perceber que bloco é que vai apanhar cada exceção.
    
    Para resolver isto, o programador deve extrair o bloco "\textit{try/catch}" para um método.\\
    
    \textbf{Remove this assignment of "id".}
    
    Campos estáticos não devem ser atualizados em construtores, mas sim serem inicializados estaticamente.
    
    Este refactoring é executado manualmente.\\
    
    \textbf{Method has 9 parameters, which is greater than 7 authorized.}
    
    Idealmente, um método não deve ter tantos parâmetros.
    Neste caso, decidimos não fazer \textit{refactoring} pois implica a alteração de muito código.\\
    
    \textbf{Remove this unused private "getX" method.}
    
    Métodos privados que não são utilizados devem ser removidos. São código desnecessário.
    
    No \textit{IntelliJ}, é possível usar a opção "\textit{Safe Delete}" para apagarmos o método.\\
    
    \textbf{Rename field "menu".}
    
    Uma variável de instância não deve ter o mesmo nome que a classe que a contém.
    
    Para resolver este problema, basta mudar o nome da variável.\\
    
    \textbf{Replace the synchronized class "Stack" by an unsynchronized one such as "Deque".}
    
    Classes sincronizadas têm um impacto muito negativo na performance da aplicação. Devem ser usadas as suas classes dessincronizadas correspondentes.
    
    No \textit{IntelliJ}, o \textit{refactoring} "\textit{Type Migration}" faz isto automaticamente, apenas é necessário selecionar a nova classe.\\
    
    
    \item \textit{\textbf{Minor}}\\
    \textbf{Move this file to a named package.}
    
    De acordo com a especificação da linguagem Java, \textit{packages} sem nome são fornecidos apenas como conveniência para projetos pequenos. Idealmente, estes não existem.
    
    No \textit{IntelliJ} basta criar um novo \textit{package} e mover o ficheiro para lá.\\
    
    \textbf{Use isEmpty() to check whether the collection is empty or not.}
    
    Para testar se uma coleção está vazia é recomendado utilizar o método \texttt{isEmpty()}. Não só é mais intuitivo como há casos em que a sua perfomance é melhor.
    
    O programador tem de fazer esta modificação manualmente.\\
    
    \textbf{Use the opposite operator (\"<=") instead.}
    
    É desnecessário inverter o resultado de uma comperação booleana. É preferíve inverter a comparação em si.
    
    O \textit{IntelliJ} disponibiliza este \textit{refactoring}.\\
    
    \textbf{The return type of this method should be an interface such as "List" rather than the implementation "ArrayList".}
    
    Declarações devem usar interfaces de coleções em vez de uma implementação específica.\\
    
    \textbf{Reorder the modifiers to comply with the Java Language Specification.}
    
    Modificadores devem ser declarados na ordem correta, seguindo a especificação da linguagem Java.\\
    
    \textbf{Remove the parentheses around the "e" parameter}
    
    Inputs lambda com um só elemento não devem ter parentesis.\\
\end{itemize}

Antes de serem aplicados os refactorings, o projeto apresentava uma \textit{technical debt} de 2 dias e 5 horas.
Após a remoção dos diversos tipos de bugs e smells, pode-se constatar a diferença nesta \textit{technical debt}:
\begin{itemize}
    \item \textbf{Blocker} - 2 dias e 2 horas, ou seja, 3 horas de diferença;
    \item \textbf{Critical} - 2 dias, ou seja, 5 horas de diferença;
    \item \textbf{Major} - 2 dias e 2 horas, ou seja, 3 horas de diferença;
    \item \textbf{Minor} - 1 dia e 5 horas, ou seja, 1 dia de diferença;
    \item \textbf{Todos} - 4 horas e 20 minutos, ou seja, 2 dias e 40 minutos de diferença;
\end{itemize}

\subsubsection{\textit{Smells} de energia}
Para além dos \textit{code smells}, desenvolveu-se mais uma versão para este demo1. 
Para isso utilizou-se o \textit{plugin} do \texttt{jStanley}, no \texttt{Eclipse}, de forma a tentar alcançar uma versão mais eficiente, do ponto de vista energético.
A análise permitiu identificar algumas possibilidades de poupanças de energia, seis no total. Veremos agora, em maior detalhe, as mudanças efetuadas.

\vspace{5mm}
\begin{itemize}

\item \textbf{Change ArrayList<Rental> by AttributeList} \\
Esta poupança de energia foi identificada no ficheiro \texttt{Controller.java}, mas foi decidido que a mesma não seria tomada em conta, uma vez que isto implicaria diversas mudanças, incluindo \textit{streams}, métodos de outras classes e afins.
Como não foi possível identificar a verdadeira extensão do impacto que teria esta mudança, tomou-se a decisão de manter a forma original.

\vspace{5mm}

\item \textbf{Change ArrayList<String> by AttributeList} \\
Esta poupança de energia apareceu cinco vezes no ficheiro \texttt{Model.java}. Por ser uma implementação mais fácil e com menos impacto em outras partes do projeto, procedeu-se às cinco alterações.
Embora simples e aparentemente poucas (num projeto extenso), estas alterações pareceram ter um impacto positivo no consumo de energia da aplicação, como veremos a seguir, no capítulo \ref{sec:rapl}.
\end{itemize}

\subsection{Versão 2 - \textit{demo2}}

Para o demo2, decidiu-se explorarem-se apenas os \textit{code smells}. De realçar que a remoção de alguns destes implicou também a remoção de alguns \textit{bugs}.

\underline{\textbf{Code Smells}}
\begin{itemize}
    \item \textit{\textbf{Blocker}}\\
    \textbf{Remove this "clone" implementation; use a copy constructor or copy factory instead.}
    
    As regras de sobreposição de \textit{clone} são demasiado complicadas de se compreenderem. Devem usar-se, em substituição, construtores por cópia. 
    
    Uma solução para este problema é apagar os métodos \textit{clone} e substituir a sua utilização por construtores de cópia. \\
    
    \item \textit{\textbf{Critical}}\\
    \textbf{Refactor this method to reduce its Cognitive Complexity from 17 to the 15 allowed}, ou equivalente.
    
    Neste caso, a maior parte da complexidade cognitiva resulta da excessiva existência de cláusulas \textit{"catch"} e/ou do aninhamento ou uso excessivo de ciclos ou "if".
    
    Uma solução para este problema utilizando o refactoring do \textit{IntelliJ}, é extrair estas partes do código para novos métodos, caso não exista outra solução.
    Ou então, para casos de usos excessivos de "if", substituí-los por "switch". Podem ainda simplificar-se os métodos. \\
    
    
    \textbf{Define a constant instead of duplicating this literal "Latitude Inválida" 6 times}, ou equivalente.

    Duplicar \textit{strings} literais dificultam o processo de refactoring, pois é necessário ter o cuidado de atualizar todas as ocorrências da \textit{string} em causa.
    Por outro lado, constantes podem ser utilizadas em vários sítios, mas só precisam de ser atualizadas num único sítio.

    Com o \textit{IntelliJ}, é possível utilizar o refactoring "\textit{Introduce Constant...}", que cria uma constante com a \textit{string} selecionada, e automaticamente substitui todos os usos deste literal pela constante criada.\\

    \textbf{Add a default case to this switch.}

    Adicionar um caso \textit{default} é programação defensiva e diminui a probabilidade do programa falhar.

    O \textit{IntelliJ} permite fazer isto automaticamente, basta selecionar a cláusula \textit{switch} e carregar na opção "\textit{Insert 'default' branch}".\\
    
    \textbf{Use static access with "java.util.Calendar" for "DAY\_OF\_MONTH"}, ou equivalente.

    Por razões de clareza, membros \textit{static} de uma class base nunca devem ser acedidos usando um nome do tipo derivado, por ser confuso e criar a ilusão de que existem dois membros \textit{static} diferentes.
    
    Com o \textit{IntelliJ}, é possível selecionar o membro e carregar na opção "\textit{Add static import for "java.util.Calendar.DAY\_OF\_MONTH"}".\\

    \textbf{Make "destino" transient or serializable}, ou equivalente.

    Campos em classes \textit{Serializable} devem ser \textit{serializable} ou \textit{transient}, mesmo que a classe nunca seja explicitamente serializada ou de-serializada.
    Isto previne falhas e ataques.
    
    A solução foi declarar as variáveis \textit{transient}. \\


    \item \textit{\textbf{Major}}\\
    \textbf{3 duplicated blocks of code must be removed}, ou equivalente. 
    
    Este \textit{code smell} é difícil de resolver, porque, por vezes, é complicado identificar os blocos de código duplicados.
    E se os mesmos forem identificados, pode ser difícil solucionar o problema.
    
    Uma possível solução poderá ser a criação de um método genérico que possibilite replicar o código. \\
    
    \textbf{Either remove or fill this block of code.}
    
    A maior parte das vezes que um bloco de código se encontra vazio é porque, de facto, existe código em falta.
    
    Nestes casos, programador deve remover ou preencher o bloco de código manualmente.\\
    
    
    \textbf{Constructor has 9 parameters, which is greater than 7 authorized}, ou equivalente.
    
    Idealmente, um método não deve ter tantos parâmetros.
    Neste caso, decidimos não fazer \textit{refactoring} pois implica a alteração de muito código. \\
    
    \textbf{Extract this nested try block into a separate method.}
    
    Para resolver isto, o programador deve extrair o bloco "\textit{try/catch}" para um método. O \textit{IntelliJ} permite fazê-lo de forma simples. \\

    
    \textbf{Remove this unused private "initApp" method.}
    
    Métodos privados que não são utilizados devem ser removidos. São código desnecessário.
    
    No \textit{IntelliJ}, é possível usar a opção "\textit{Safe Delete}" para apagarmos o método. Esta opção verifica que não existem chamadas deste método e que é seguro apága-lo. \\
    
    \textbf{Rename "consumo" which hides the field declared at line 33}, ou equivalente.
    
    Uma variável declarada num \textit{scope} mais exterior não deve ser sobreposta ou escondida por outra, impactando a legibilidade e, consequentemente, manutenibilidade do código. Pode também potenciar a criação de futuors \textit{bugs}.
    
    Para resolver este problema, basta mudar o nome da variável.\\
    
    
    \textbf{Add the "@Override" annotation above this method signature.}

    Usar anotações aumenta a legibilidade do código ao tornar óbvio que um método é sobreposto.

    A solução é adicionar a anotação por cima do método. \\


    \textbf{Remove this "Double" constructor.}

    Construtores para \textit{String, Double} e outros objetos usados para "embrulhar" primitivas nunca devem ser usados.
    Usá-los é menos claro e utiliza mais memória.

    O \textit{IntelliJ} permite remover facilmente estes "embrulhos" com a opção "\textit{Remove boxing}". \\


    \textbf{Remove this useless assignment to local variable "kilometers"}, ou equivalente.

    Quando um valor é calculado e depois não é utilizado, pode haver um erro no código, ou então um desperdício de recursos.

    Nestes casos, deve apagar-se a atribuição, ou então alterar o código subsequente por forma a utilizar essa atribuição. \\


    \textbf{Replace this use of System.out or System.err by a logger}

    Se um programa escreve diretamente para o \textit{standard output}, informações sensíveis podem ser expostas.

    Apesar disto, foi decidido que não se iriam tratar estes \textit{smells} porque a maioria das escritas para o \textit{standard output} implica a interface criada. \\


    \textbf{Add a private constructor to hide the implicit public one.}

    Classes de utilidade não devem ser instanciadas. O Java adiciona um construtor público implícito por cada classe que não defina um explicitamente.

    A solução é adicionar um construtor privado à classe, que pode até ser vazio. \\


    \textbf{This block of commented-out lines of code should be removed.}

    Código não utilizado deve ser apagado e não comentado.

    O código comentado deve ser apagado. \\


    \textbf{Merge this if statement with the enclosing one.}

    Fundir "ifs" aumenta a legibilidade do código.

    Nestes casos, deve fundir-se o \textit{if} aninhado com o anterior. Este \textit{refactoring} deve ser feito manualmente. \\


    \textbf{Make this anonymous inner class a lambda.}

    Classes anónimas podem ser complicadas e incertas.

    O \textit{IntelliJ} dá a opção "\textit{Replace with lambda}" para estes casos. \\


    \item \textit{\textbf{Minor}}\\
    \textbf{Move this file to a named package.}
    
    De acordo com a especificação da linguagem Java, \textit{packages} sem nome são fornecidos apenas como conveniência para projetos pequenos. Idealmente, estes não existem.
    
    No \textit{IntelliJ} basta criar um novo \textit{package} e mover o ficheiro para lá.\\
    

    \textbf{Use isEmpty() to check whether the collection is empty or not.}
    
    Para testar se uma coleção está vazia é recomendado utilizar o método \texttt{isEmpty()}. Não só é mais intuitivo como há casos em que a sua perfomance é melhor.
    
    O programador tem de fazer esta modificação manualmente.\\
    

    \textbf{Use super.clone() to create and seed the cloned instance to be returned.}
    
    Sobrepôr o método \textit{clone()} sem implementar \textit{Clonable} pode indicar um erro.
    
    O \textit{IntelliJ} disponibiliza este \textit{refactoring}, no entanto, este pode implicar outras alterações no código que o programador deve ter em atenção.
    De realçar que este \textit{refactoring} pode ser desnecessário, uma vez que outros \textit{smells} podem implicar a eliminação do método em questão. \\
    

    \textbf{Rename the interface name to match the regular expression '\^[A-Z][a-zA-Z0-9]*\$'.}
    
    Convenções de código é algo que permite uma colaboração mais eficiente entre equipas e programadores. Esta regra diz que os nomes das constantes devem seguir aquela expressão regular.
    
    No \textit{IntelliJ}, basta fazer "\textit{Rename}" à variável. \\
    

    \textbf{Remove this unused import 'java.util.ArrayList'.}
    
    Importar bibliotecas que não são usadas reduz a legibilidade do código, uma vez que a sua presença pode causar confusão.
    
    Pode utilizar-se a opção \textit{Optimize imports} para todo o projeto, de modo a resolver todas as ocorrências deste \textit{smell} de uma só vez. \\
    

    \textbf{Remove the literal "true" boolean value}, ou equivalente.
    
    Literais booleanos redundantes devem ser removidos de expressões de modo a melhorar a legibilidade do código.
    
    O \textit{IntelliJ} identifica estes casos e permite a simplicação dos mesmos, com a opção \textit{Simplify}. \\


    \textbf{Rename this field "MIN\_LATITUDE" to match the regular expression '\^[a-z][a-zA-Z0-9]*\$'}, ou equivalente.

    A opção "\textit{Rename}", do \textit{IntelliJ}, permite alterar todas as ocorrências do campo no projeto. É apenas necessário que se escreva um nome que corresponda à expressão regular. \\


    \textbf{Use "Double.parseDouble" for this string-to-double conversion.}

    Em vez de se criar uma primitiva "embrulhada" de uma \textit{String} para extrair um valor primitivo, deve usar-se o método "parse". O código fica mais claro e mais eficiente.

    Também neste casos, o \textit{IntelliJ} permite fazer este \textit{refactoring} de forma simples. \\


    \textbf{Replace this if-then-else statement by a single return statement.}

    Deve simplificar-se o retorno de literais booleanos em "if-then-else".

    Mais uma vez, o \textit{IntelliJ} permite simplicar estas expressões de forma simples. \\


    \textbf{Remove this use of "Double"; it is deprecated.}

    Uma vez descontinuadas, classes, interfaces e os seus membros devem ser evitados.

    No caso de ocorrências de "Double", não só a classe foi descontinuada, como também é desnecessário o seu uso. Daí, normalmente, a solução será remover o "embrulho".
    Essa é opção é oferecida pelo \textit{IntelliJ}. \\

    
    \textbf{Remove this unused "kilometers" local variable}, ou equivalente.

    Manutenibilidade é incrementada se os programadores não tiverem de descobrir para o que é que uma variável é usada. Por isso, variáveis declaradas e não usadas, devem ser removidas.

    Tal como noutras situações semelhantes, o \textit{IntelliJ} reconhece variáveis não usadas e dá a opção de remoção das mesmas. \\


    \textbf{Replace the type specification in this constructor call with the diamond operator ("<>").}

    O compilador consegue inferir o tipo, no construtor, através da declaração.

    Assim, podem apagar-se os tipos nos construtores, deixando apenas o operador "<>". \\


    \textbf{Reduce the total number of break and continue statements in this loop to use at most one.}

    Este \textit{refactoring} é feito no interesse boa programação estruturada.

    O programador tem de reduzir o número destas expressões manualmente. O uso de "if" e booleanos pode ajudar.


    \textbf{Declare "nif" on a separate line.}

    Declarar múltiplas variáveis na mesma linha é difícil de ler.

    O \textit{IntelliJ} permite, através da opção "\textit{Split into separate declarations}", separar as declarações de todas as variáveis na mesma linha, para linhas diferentes.


    \textbf{Immediately return this expression instead of assigning it to the temporary variable "car"}, ou equivalente.

    É uma má prática declarar uma variável para, logo a seguir, a retornar.

    A opção "\textit{Inline variable}", oferecida quando a variável é clicada, permite substituir a declaração da variável pelo seu retorno imediato.
\end{itemize}

Antes de serem aplicados os refactorings, o projeto apresentava uma \textit{technical debt} de 6 dias.
Após a remoção dos diversos tipos de smells, pode-se constatar a diferença nesta \textit{technical debt}:
\begin{itemize}
    \item \textbf{Blocker} - 5 dias, ou seja, 1 dia de diferença;
    \item \textbf{Critical} - 4 dias, ou seja, 2 dias de diferença;
    \item \textbf{Major} - 4 dias, ou seja, 2 dias de diferença;
    \item \textbf{Minor} - 2 dias, ou seja, 4 dias de diferença;
    \item \textbf{Todos} - 0 dias, ou seja, 6 dias de diferença;
\end{itemize}

Pode chamar à atenção o facto de, a soma da redução do \textit{technical debt} para cada categoria, ser superior ao inicial (6 dias).
No entanto, isto é facilmente explicável pelo facto de alguns \textit{smells} se sobreporem, ou seja, a remoção de um de uma categoria, pode querer dizer que outro, de outra categoria, também seja resolvido.

As diferenças entre categorias podem ser explicadas pelas quantidades distintas de \textit{smells} de cada uma.

\section{Tarefa 3 - Teste da aplicação}
Nesta tarefa, tal como o nome da mesma transparece, serão utilizadas técnicas de teste de \textit{software} para efectuar testes unitários em \textit{JUnit} e, ainda, o
teste de regressão da aplicação \textit{UmCarroJá}. Para além disso, serão utilizadas sistemas para a geração automática de casos de teste para gerar testes unitários e ainda inputs para simular a execução real da aplicação. De notar que nesta etapa também se procede à análise de testes unitários através do \textit{code coverage runner} disponibilizado pelo \textit{IntelliJ}.

\subsection{Versão 1 - \textit{demo1}}

\subsubsection{Testes unitários - \textit{JUnit}}

Como iremos ver de seguida, a maior parte dos testes unitários são gerados automaticamente pelo o \textit{EvoSuite}, mas além disso, decidimos fazer uma pequena análise pessoal ao código do projeto.
Concentramos a nossa análise no \textit{package} \texttt{Model}, mais especificamente nas classes \texttt{Cars}, \texttt{Rentals} e um \texttt{UmCarroJa}, que achamos que são as mais relevantes a nível de evolução do sistema.

Estes testes foram colocados no \textit{package} \texttt{test} e estão devidamente anotados seguindo a anotação dos testes manuais do \textit{JUnit}.

Quanto à cobertura, a análise efetuada pelo \textit{IntelliJ} (com destaque apenas no \textit{package} \texttt{Model}) mostra que obtivemos um total de cobertura de: 96\% em classes, 46\% em métodos e 36\% em linhas de código.

Como seria de esperar, os testes não apresentam grande cobertura na totalidade da aplicação, pois é complicado cobrir todos os casos devido à elevada extensão da implementação deste projeto. 

Uma verdadeira análise de cobertura encontra-se no ponto seguinte, onde é descrita a geração automática de testes unitários com o \textit{EvoSuite}.

\subsubsection{Geração automática de testes unitários - \textit{EvoSuite}}
Usou-se o \textit{plugin} do \textit{IntelliJ} para utilizar o \textit{EvoSuite} no projeto, gerando testes unitários de forma automática para todo o projeto.


Foi possível, com recurso à opção \texttt{Run with coverage} do \textit{IntelliJ}, fazer a \textbf{análise de cobertura de código}.
De seguida, apresentam-se os resultados obtidos.

\begin{table}[h] 
    \caption{Análise do consumo energético - \textit{demo1}}
    \begin{center}
        \begin{tabular}{ || c | c | c | c || }
        \hline
        \textbf{\textit{Package}/Classe} & \textbf{Classes} & \textbf{Métodos} & \textbf{Linhas} \\
        \hline
        \hline
        Controller & 100\% (2/2) & 100\% (5/5) & 92\% (207/225) \\
        \hline
        Exceptions & 69\% (9/13) & 100\% (0/0) & 100\% (9/9) \\
        \hline
        Model & 100\% (13/13) & 100\% (134/160) & 77\% (515/661) \\
        \hline
        Utils & 100\% (2/2) & 39\% (11/28) & 50\% (20/40) \\
        \hline
        View & 100\% (13/13) & 100\% (75/75) & 100\% (421/441) \\
        \hline
        Main.java & 100\% (1/1) & 100\% (1/1) & 83\% (10/12) \\
        \hline
        \end{tabular} 
    \end{center}
\end{table}

A partir desta tabela, podemos perceber que quase todo o código é executado. No entanto, percebe-se que certas partes do mesmo não o são, pelo que a sua remoção deve ser pensada.
É fácil perceber que algumas das exceções poderiam ser descartadas. Importa realçar que esta análise foi apenas feita ao código original, ou seja, sem qualquer tipo de \textit{refactoring}. 
A análise de outras versões, pós-\textit{refactoring}, poderá apresentar ligeiras melhorias.

\subsubsection{Geração automática de testes - \textit{QuickCheck}} \label{sssec:QuickCheckDemo1}
Nesta sub-tarefa foi-nos proposto gerar automaticamente ficheiros de \textit{logs} para testar a aplicação \textit{UmCarroJá}. Como seria de esperar, foi adoptada a utilização do sistema \textit{QuickCheck} para o efeito, tal como foi feito nas aulas.

A implementação do gerador pretendido segue, naturalmente, a estrutura apresentada pelo exemplo disponibilizado pelos docentes na página da disciplina. Como tal, foi necessário criar essencialmente 5 tipos de geradores, cada um com o seu tipo de dados:
\begin{itemize}
    \item \textit{NovoProp}: registo de um novo proprietário;
    \item \textit{NovoCliente}: registo de um novo cliente;
    \item \textit{NovoCarro}: registo de um novo carro;
    \item \textit{Aluguer}: registo de um aluguer efetuado por um cliente;
    \item \textit{Classificar}: classificação atribuída a um carro ou a um cliente/proprietário.
\end{itemize}

Também é preciso salientar que existe uma diversidade considerável de atributos associados a estes novos tipos (como por exemplo, \textit{emails}, nomes, marcas, moradas, entre outros). Por forma a garantir uma grande variedade de atributos, a maior parte dos geradores implementados utiliza o combinador \textit{frequency}. Este gerador associa a um determinado tipo de dados uma probabilidade de escolha. Consequentemente, foi possível gerar nomes, apelidos, moradas e marcas de automóveis de forma mais realista e em grande escala. De notar também que os elementos deste grupo tiveram em consideração a geração de \textit{NIF's} e de matrículas sem repetições, permitindo assim uma simulação fidedigna e correta da aplicação.

Por fim, de maneira a executar o gerador proposto, foi necessário parametrizar numa variável o número de registos a serem escritos para o ficheiro \textit{logs.bak} que irá armazenar toda esta informação. Desta forma, durante a execução da função \textbf{\textit{genLogsIO}} (responsável por gerar todos os registos dos tipos de dados mencionados anteriormente), é perguntado ao utilizador quantos registos pretende produzir.

\subsection{Versão 2 - \textit{demo2}}

\subsubsection{Testes unitários - \textit{JUnit}}
Como se pôde constatar na primeira versão da implementação deste projeto de \textit{POO} (isto é, na \textit{demo1}), a especificação de testes unitários em \textit{JUnit} acaba por ser inviável uma vez que existe uma elevada extensão de classes. Como tal, de forma a ser relevante a execução desta tarefa, seria necessário desenvolver muitos casos de teste para estas classes. Só desta forma obter-se-ia uma cobertura de testes muito próximo dos 100\%. 
Dada a existência de ferramentas computacionais que tratam a geração automática de testes unitários, como é o caso do \textit{EvoSuite}, optou-se por dar prioridade a utilização deste utensílio para este tipo de tarefa.

\subsubsection{Geração automática de testes unitários - \textit{EvoSuite}}
Quanto à geração automática de testes unitários, foi possível gerar corretamente todos as classes de teste. No entanto, ao correr não foi possível obter resultados fidedignos, devido ao mau funcionamento do programa em questão. Quanto à cobertura dos testes, foi possível verificar, tal como é expectável, más percentagens a este respeito.

\subsubsection{Geração automática de testes - \textit{QuickCheck}}
Relativamente à geração automática de testes em \textit{QuickCheck}, a abordagem tomada nesta implementação foi exatamente igual à que foi explorada anteriormente na primeira versão (ver informação no capítulo \ref{sssec:QuickCheckDemo1}).

\section{Tarefa 4 - Análise de desempenho}
\label{sec:rapl}
\subsection{Versão 1 - \textit{demo1}}
Após as diversas alterações e eliminações de \textit{smells} é necessário verificar se estas tiveram impacto sobre o desempenho do programa. Para tal foi utilizada a ferramenta \textit{RAPL}, disponibilizada pelos docentes, para analisar o consumo energético do programa. Como primeira etapa foram registados os valores energéticos com \textit{logs} de diversos tamanhos (5, 55, 5555, 55555). De seguida encontram-se as tabelas com os resultados obtidos:

\begin{table}[h] 
    \caption{Análise do consumo energético - \textit{demo1}}
    \begin{center}
        \begin{tabular}{>{\centering}p{0.1\textwidth}>{\centering}p{0.13\textwidth}>{\centering}p{0.21\textwidth}>{\centering}p{0.22\textwidth}>{\centering\arraybackslash}p{0.2\textwidth}}
        \toprule \textbf{\textit{Smells}?} & \textbf{Tamanho do \textit{input}} & \textbf{\textit{dram}} (em \textit{MB}) & \textbf{\textit{cpu}} (em \textit{ms}) & \textbf{\textit{package}} (em \textit{J}) \\
        \midrule Sim &  5 &  0.024292000000002645 &  0.1289059999999722 & 0.258239999999887 \\
        \midrule Não &  5 &  0.04699700000003304  & 0.10449199999993652 & 0.3303230000001349 \\
        \midrule \\
        \midrule Sim &  55 &  0.18859800000001314 &  0.3990479999999934 & 1.139159999999947 \\
        \midrule Não &  55 &  0.078185999999959684  &   0.31451400000003105 & 0.7086789999998473 \\
        \midrule \\
        \midrule Sim &  5555 &  0.3440559999999664 &  3.8085930000000303 & 5.577698000000055 \\
        \midrule Não &  5555 &  0.32525699999996505  &  3.6011349999999993 & 5.260498000000098 \\
         \midrule \\
        \midrule Sim &  55555 &  3.675475999999435 &  59.24536100000114 & 89.38207999999577 \\
        \midrule Não &  55555 &  3.8429559999999583  &  60.6569210000016  & 91.23339899999701 \\
        \bottomrule
        \end{tabular} 
    \end{center}
\end{table}

\subsection{Versão 2 - \textit{demo2}}

\begin{table}[h] 
    \caption{Análise do consumo energético - \textit{demo2}}
    \begin{center}
        \begin{tabular}{>{\centering}p{0.1\textwidth}>{\centering}p{0.13\textwidth}>{\centering}p{0.2\textwidth}>{\centering}p{0.22\textwidth}>{\centering\arraybackslash}p{0.2\textwidth}}
        \toprule \textbf{\textit{Smells}?} & \textbf{Tamanho do \textit{input}} & \textbf{\textit{dram}} (em \textit{MB}) & \textbf{\textit{cpu}} (em \textit{ms}) & \textbf{\textit{package}} (em \textit{J}) \\
        \midrule Sim & original & 2.5678709999999683 & 30.438354000000004 & 41.03033400000004 \\
        \midrule Não & --- & --- & --- & --- \\
        \bottomrule
        \end{tabular} 
    \end{center}
\end{table}

\subsection{Tarefa extra}
Nesta tarefa adicional é requerido uma análise detalhada por cada \textit{smell}. Dito por outras palavras, é necessário fazer um estudo sobre como cada \textit{smell} individualmente influência (melhora ou piora) o desempenho do \textit{software}. 
Como tal, foram executadas ambas as versões do programa em questão com cada tipo de \textit{smells} de forma isolada. Consequentemente, sobre um conjunto de funções do programa, obtiveram-se os seguintes resultados:

\begin{table}[h] 
    \caption{Análise do consumo energético \textit{smell} a \textit{smell} - \textit{demo1 -> logs original} }
    \begin{center}
        \begin{tabular}{>{\centering}p{0.14\textwidth}>{\centering}p{0.2\textwidth}>{\centering}p{0.22\textwidth}>{\centering\arraybackslash}p{0.2\textwidth}>{\centering}p{0.1\textwidth}}
        \toprule \textbf{\textit{Smells}} & \textbf{\textit{dram}} (em \textit{MB}) & \textbf{\textit{cpu}} (em \textit{ms}) & \textbf{\textit{package}} (em \textit{J}) & \textbf{Tempo} (em \textit{ms}) \tabularnewline
        
        \midrule \textit{noMinor} & 0.125 & 1.8643190000002505 & 2.6281740000013087 & 56 \tabularnewline
        \midrule \textit{noMajor} & 0.10607900000013615 & 1.8434440000000905 & 2.383972999999969 & 67 \tabularnewline
        \midrule \textit{noCritical} & 0.10449199999993652 & 1.999877999999626 & 2.481445999999778 & 55 \tabularnewline
        \midrule \textit{noBlocker} & 0.10296599999992395 & 1.799011000000064 & 2.240355999998428 & 53  \tabularnewline
        \midrule \textit{noRedSmells} & 0.12378000000035172 & 2.0324699999996483 & 2.7041619999999966 & 51  \tabularnewline
        \midrule \textit{noSmells} & 0.10351600000012695 & 1.7691039999999703 & 2.2634280000002036 & 62  \tabularnewline
        \bottomrule
        \end{tabular} 
    \end{center}
\end{table}

\begin{table}[h] 
    \caption{Análise do consumo energético \textit{smell} a \textit{smell} - \textit{demo1 -> logs tamanho 55555}}
    \begin{center}
        \begin{tabular}{>{\centering}p{0.14\textwidth}>{\centering}p{0.2\textwidth}>{\centering}p{0.22\textwidth}>{\centering\arraybackslash}p{0.2\textwidth}>{\centering}p{0.1\textwidth}}
        \toprule \textbf{\textit{Smells}} & \textbf{\textit{dram}} (em \textit{MB}) & \textbf{\textit{cpu}} (em \textit{ms}) & \textbf{\textit{package}} (em \textit{J}) & \textbf{Tempo} (em \textit{ms}) \tabularnewline
        
        \midrule \textit{noMinor} & 12.97338899999977 & 168.750792999999255 & 304.18981899999926 & 17032 \tabularnewline
        \midrule \textit{noMajor} & 12.753662000000077 & 164.5404660000022 & 295.9130860000005 & 16745 \tabularnewline
        \midrule \textit{noCritical} & 13.174987999999757 & 168.60394299999825 & 302.7049559999941 & 17144 \tabularnewline
        \midrule \textit{noBlocker} & 15.805237000000034 & 183.67248599999948 & 324.94183299999713 & 17329  \tabularnewline
        \midrule \textit{noRedSmells} & 12.960143999999673 & 168.22857600000134 & 298.2542109999995 & 16595  \tabularnewline
        \midrule \textit{noSmells} & 12.254883000000063 & 160.48974599999933 & 288.387023999996 & 16128  \tabularnewline
        \bottomrule
        \end{tabular} 
    \end{center}
\end{table}

\begin{table}[h] 
    \caption{Análise do consumo energético \textit{smell} a \textit{smell} - \textit{demo2}}
    \begin{center}
        \begin{tabular}{>{\centering}p{0.14\textwidth}>{\centering}p{0.2\textwidth}>{\centering}p{0.22\textwidth}>{\centering\arraybackslash}p{0.2\textwidth}>{\centering}p{0.1\textwidth}}
            \toprule \textbf{\textit{Smells}} & \textbf{\textit{dram}} (em \textit{MB}) & \textbf{\textit{cpu}} (em \textit{ms}) & \textbf{\textit{package}} (em \textit{J}) & \textbf{Tempo} (em \textit{ms}) \tabularnewline
        \midrule \textit{noMinor} & --- & --- & --- & --- \tabularnewline
        \midrule \textit{noMajor} & 2.204895000000306 & 24.839966000000004 & 34.237121999998635 & 1119 \tabularnewline
        \midrule \textit{noCritical} & 2.4993890000000647 & 29.64740000000029 & 40.53625499999998 & 1282 \tabularnewline
        \midrule \textit{noBlocker} & --- & --- & --- & --- \tabularnewline
        \midrule \textit{noRedSmells} & ---  & --- & --- & --- \tabularnewline
        \midrule \textit{noSmells} & ---  & --- & --- & --- \tabularnewline
        \bottomrule
        \end{tabular} 
    \end{center}
\end{table}

\chapter{Conclusão}
Após a demonstração da abordagem tomada para cada uma das tarefas propostas neste trabalho prático e, ainda, a exibição dos resultados obtidos em cada uma das mesmas, dá-se por concluído a execução deste projeto. 
Durante o processo de realização do mesmo foi possível analisar o código fonte de ambas as versões implementadas, identificando os \textit{bad smells} e o seu \textit{technical debt}. Posteriormente, foram aplicados \textit{refactorings}
de maneira a eliminar os \textit{bad smells} encontrados e, deste modo, reduzir o respetivo \textit{technical debt}. Numa terceira fase, foi testado com sucesso o \textit{software} em questão de forma a garantir que o mesmo exprimia o 
comportamento esperado. E, por fim, foi realizada uma análise a nível do desempenho das duas versões implementadas (antes e depois da aplicação de \textit{refactorings}).

Depois de terminadas as tarefas, refletimos sobre os resultados obtidos e das conclusões que podemos tirar, tanto desses resultados como do trabalho realizado.

A primeira tarefa foi importante para assimilarmos alguns dos conteúdos lecionados ao longo da UC, mas também, e principalmente, para termos uma ideia inicial do projeto que analisávamos e do extenso trabalho que teríamos pela frente.
Pudemos ainda perceber a importância destas análises para uma manutenção mais fácil do código.

A segunda tarefa, talvez a mais extensa de todas, obrigou à criação de diversas versões do mesmo código. Foi importante para os elementos deste grupo perceberem, e futuramente corrigirem, as (suas) más práticas de programação.
Permitiu ainda desenvolver um conhecimento mais profundo do projeto, essencial para a realização da próxima tarefa.

A terceira tarefa resume-se à geração de teste unitários, automáticos ou não. Os testes são importantes no desenvolvimento de \textit{software}, porque permitem identificar potenciais problemas e resolvê-los.

Para a quarta tarefa, realizaram-se análises o desempenho do(s) projeto(s) analisado(s). Para além das versões originais, também se fez uma análise das versões desenvolvidas ao longo deste extenso trabalho.
É desta tarefa que podemos retirar mais conclusões. Pode perceber-se, com recurso às tabelas apresentadas, que o tratamento e eliminação de alguns dos diferentes tipos de \textit{smells} não têm um grande impacto no desempenho da aplicação.
No entanto, parece haver uma tendência para um melhor desempenho, quando fazemos a análise \textit{smell} a \textit{smell}. 
Ainda assim, pode argumentar-se que o tratamento de \textit{code smells} realizado, tinha como objetivo melhorar a legibilidade e manutenibilidade do código, pelo que uma melhoria no desempenho é sempre um extra.

Em nota final, podemos concluir que os erros e más práticas são mais comuns do que poderíamos pensar antes de iniciarmos este projeto. É então importante dedicar algum tempo para a análise, \textit{refactoring} e teste do código.
Não apenas quando o mesmo está terminado, mas também em outras fases do desenvolvimento.


\appendix
\chapter{Observações}
Durante a análise da primeira tarefa associada a este trabalho prático observaram-se, na ferramenta \textit{\textbf{Sonarqube}}, variados tipos de severidade de erros. Como tal, apresentam-se de seguida, de forma mais detalhada, os mesmos:
\begin{itemize}
    \item \textbf{\textit{minor}}:
    \\ Falha que afeta a qualidade do código e que pode ter um impacto minorativo na produtividade do programador: linhas de código longas, entre outros.
    \item \textbf{\textit{major}}:
    \\ Falha que afeta a qualidade do código e que pode ter um impacto significativo na produtividade do programador: blocos duplicados, parâmetros não utilizados, entre outros.
    \item \textbf{\textit{critical}}:
    \\ Erro com baixa probabilidade de afetar o comportamento da aplicação em produção ou um problema que representa uma falha de segurança. O código deve ser examinado imediatamente.
    \item \textbf{\textit{blocker}}:
    \\ Erro com alta probabilidade de afetar o comportamento da aplicação em produção. O código deve ser corrigido imediatamente.
\end{itemize}

\end{document}