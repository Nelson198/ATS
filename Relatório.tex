% Setup -------------------------------

\documentclass[a4paper]{report}
\usepackage[a4paper, total={6in, 10in}]{geometry}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

% Encoding
%--------------------------------------
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
%--------------------------------------

% Portuguese-specific commands
%--------------------------------------
\usepackage[portuguese]{babel}
%--------------------------------------

% Hyphenation rules
%--------------------------------------
\usepackage{hyphenat}
%--------------------------------------

% Capa do relatório

\title{
    Análise e Teste de Software
    \\ \Large{\textbf{Trabalho Prático}}
    \\ -
    \\ Mestrado em Engenharia Informática
    \\ \large{Universidade do Minho}
    \\ Relatório
}
\author{
    \begin{tabular}{ll}
        \textbf{Grupo nº3}
        \\\hline
        PG41091 & Nelson José Dias Teixeira
        \\
        PG41081 & José Alberto Martins Boticas
        \\
        PG41094 & Pedro Rafael Paiva Moura
        \\
        A80499  & Moisés Manuel Borba Roriz Ramires
    \end{tabular}
}

\date{\today}

\begin{document}

\begin{titlepage}
    \maketitle
\end{titlepage}

% Resumo

\begin{abstract}
    No ano lectivo 2018/2019, no contexto da disciplina de Programação Orientada a Objectos
    (POO) leccionada no Departamento de Informática da Universidade do Minho, os alunos
    tiveram de desenvolver em grupo uma aplicação Java, denominada por  \textit{UmCarroJá}, para gerir um serviço de aluguer de
    veículos particulares pela internet.\,\,No contexto da disciplina de Análise e Teste de Software (ATS) pretende-se que neste projeto se apliquem técnicas de análise e teste de software, estudadas nas aulas, de modo a analisar a qualidade de duas das soluções desenvolvidas pelos alunos de POO.
\end{abstract}

% Índice

\tableofcontents

% Introdução

\chapter{Introdução} \label{intro}
\large{
    Neste projeto foi-nos proposto a realização de várias tarefas de forma a analisar a qualidade das duas soluções desenvolvidas pelos alunos de POO no ano lectivo de 2018/2019. Entre estas tarefas destacam-se as seguintes:
    \begin{enumerate}
        \item Analisar a qualidade do código fonte dos sistemas de \textit{software}. Nesta análise identificam-se \textit{bad smells} no código fonte e o seu \textit{technical debt};
        \item Aplicar \textit{refactorings} de modo a eliminar os \textit{bad smells} encontrados e deste modo reduzir (se possível eliminar) o \textit{technical debt};
        \item Testar o \textit{software} de modo a ter mais garantias que ele cumpre os requisitos do enunciado da aplicação \textit{UmCarroJá};
        \item Gerar \textit{inputs} aleatórios para a aplicação \textit{UmCarroJá} que simulem execuções reais (tal como foi fornecido em POO);
        \item Analisar a performance (tempo de execução e consumo de energia) das versões iniciais do \textit{software} (i.e., com \textit{smells}) e as obtidas depois de eliminados os \textit{smells}.
    \end{enumerate}
    Os cinco pontos mencionados acima foram agrupados em quatro tarefas finais, cada uma das quais com uma percentagem na avaliação final do trabalho prático. As abordagens tomadas pelo grupo sobre cada uma destas tarefas serão expostas nos capítulos seguintes deste relatório.
    De salientar que também existem tarefas extras que complementam cada uma das tarefas referidas anteriormente.
}

\chapter{Análise e Especificação}
\section{Tarefa 1 - Qualidade do código fonte}
Nesta etapa, tal como o nome indica, será feita a análise da qualidade do código fonte da aplicação \textit{UmCarroJá} desenvolvido pelos alunos de POO. Como tal, através da ferramenta \underline{\textit{Sonarqube}}, serão indicados o número de erros no código (\textit{bugs}), vulnerabilidades, \textit{code smells} e o respetivo \textit{technical debt}. Para além destas, existe uma \textbf{tarefa extra} que consiste em definir regras adicionais na ferramenta \textit{Sonarqube} para encontrar \textit{red smells} (ou qualquer outro \textit{smell} não suportado pelo mesmo) na aplicação desenvolvida.

\subsection{Versão 1 - \textit{demo1}}
Na primeira versão desenvolvida pelos alunos de POO, \textit{demo1}, foi possível observar alguns erros no código fonte e bastantes \textit{code smells}. Apresenta-se de seguida, por categorias, a análise qualitativa desta mesma implementação.

\subsubsection{Fiabilidade}
Nesta secção da análise qualitativa da aplicação desenvolvida observam-se e identificam-se unicamente os erros (\textit{bugs}) presentes no código fonte.
Como tal, após verificar a informação existente na ferramenta \textit{Sonarqube}, os elementos deste grupo depararam-se, essencialmente, com quatro tipos de erros. Entre eles destacam-se:

\begin{enumerate}
    \item a implementação do método \textit{equals()} numa determinada classe sobrepõe a predefinida, pelo que também deve ser codificado o método \textit{hashCode()};
    \item o método \textit{equals()} presente numa determinada classe necessita de ser sobreposto à implementação predefinida ou, simplesmente, renomeado;
    \item o objeto \textit{Random} presente numa determinada classe deve ser reutilizado;
    \item o objeto \textit{ObjectOutputStream} deve ser fechado através de uma clausula \textit{try-catch-finally}.
\end{enumerate}

Na totalidade existem cerca de \textbf{14 erros} no código fonte. Quanto à severidade destes erros, existem 2 de tipo \textit{blocker}, 2 de tipo \textit{critical}, 1 de tipo \textit{major} e 9 de tipo \textit{minor}.
\par De salientar que, apesar da existência de alguns erros presentes nesta implementação, estes são facilmente corrigíveis.

\subsubsection{Segurança}
Ao nível da segurança, esta implementação apresenta apenas \textbf{uma vulnerabilidade} cujo grau de severidade é do tipo \textit{minor}. A ferramenta \textit{Sonarqube}, por forma a eliminar esta mesma, sugere encapsular a amostragem de um determinado erro através de um objeto \textit{LOGGER}. Dado que existe uma e uma só vulnerabilidade deste tipo, o \textit{software} \textit{Sonarqube} atribui nota \textit{B} a este contexto. De notar também que existem 22 casos no código fonte que precisam de ser revistos por forma a verificar se existem ou não ainda mais vulnerabilidades.

\subsubsection{Manutenção}
Neste segmento do relatório, observam-se e identificam-se os \textit{code smells}. Estes inferem o grau de interpretabilidade do código fonte e, por isso, permitem avaliar se é ou não possível evoluir a versão atual do programa desenvolvido.

Neste caso, foi possível verificar a existência de \textbf{131 \textit{code smells}}. Apresentam-se de seguida o grau de severidade de cada um destes:
\begin{itemize}
    \item \textbf{\textit{minor}}: 60 ocorrências;
    \item \textbf{\textit{major}}: 24 ocorrências;
    \item \textbf{\textit{critical}}: 41 ocorrências;
    \item \textbf{\textit{blocker}}: 6 ocorrências.
\end{itemize}

Como se pode constatar, cerca de 54\% dos \textit{code smells} possuem uma gravidade considerável, pelo que se pode inferir que esta implementação levará, potencialmente, a uma interpretabilidade razoável por parte do programador.

Segundo a ferramenta \textit{SonarQube}, demoraria cerca de 2 dias e 5 horas a corrigir todos estes "defeitos". Este facto traduz aquilo a que chamamos o \textit{technical debt}, isto é, a probabilidade de ocorrências de erros no futuro. Esta ferramenta atribui a nota \textit{A} no que diz respeito ao \textit{technical debt}.

\subsubsection{Cobertura}
Quanto à cobertura não foram testados nenhuns aspetos intrínsecos a esta implementação.

\subsubsection{Duplicação de código}
No que diz respeito à duplicação de código existem cerca de 2 blocos repetidos numa das classes implementadas, representando apenas 1\% do código total.

\subsection{Versão 2 - \textit{demo2}}
Na segunda versão desenvolvida pelos alunos de POO, \textit{demo2}, foi possível observar bastantes erros no código fonte e muitos \textit{code smells}. Apresenta-se de seguida, por categorias, a análise qualitativa desta mesma implementação.

\subsubsection{Fiabilidade}
Nesta secção da análise qualitativa da aplicação desenvolvida observam-se e identificam-se unicamente os erros (bugs) presentes no código fonte.

Após consultar a informação presente na ferramenta \textit{Sonarqube}, foi possível verificar que, no total, existem \textbf{33 \textit{bugs}} nesta implementação, sendo que 27 são do tipo \textit{minor}, 2 são do tipo \textit{major} e 4 são do tipo \textit{blocker}.

Todos estes erros estão contidos em 6 categorias. Apresenta-se de seguida não só estas últimas como também o respetivo número de erros associados à mesma:
\begin{enumerate}
    \item a implementação do método \textit{equals()} numa determinada classe sobrepõe a predefinida, pelo que também deve ser codificado o método \textit{hashCode()} (10 ocorrências);
    \item \textit{boxing} e \textit{unboxing} de objetos não devem ser imediatamente revertidos (10 ocorrências);
    \item necessidade de realizar \textit{cast} a um dos operandos na operação de divisão (7 ocorrências);
    \item objetos do tipo \textit{ObjectInputStream}, \textit{ObjectOutputStream}, \textit{FileInputStream} e \textit{BufferedReader} devem ser fechados através de uma clausula \textit{try-catch-finally} (4 ocorrências);
    \item objetos do tipo \textit{Calendar} não devem conter a referência \textit{static} e, como tal, devem ser instanciados (1 ocorrência);
    \item a exceção \textit{NullPointerException} pode ser lançada e, como tal, deve ser utilizada a cláusula \textit{try-catch} para prevenir a referência a um apontador nulo (1 ocorrência).
\end{enumerate}

\par De salientar que, apesar da existência de vários erros nesta implementação, estes são corrigíveis.

\subsubsection{Segurança}
Ao nível da segurança, esta implementação apresenta \textbf{10 vulnerabilidades} cujo grau de severidade é do tipo \textit{minor}. Consequentemente, a ferramenta \textit{Sonarqube} atribui nota \textit{B} a este contexto, dado que existe pelo menos uma vulnerabilidade do tipo \textit{minor}. Todas estas vulnerabilidades baseiam-se, de forma global, na transformação de variáveis em constantes. De notar também que existem 16 casos no código fonte que precisam de ser revistos por forma a verificar se existem ou não ainda mais vulnerabilidades.

\subsubsection{Manutenção}
Neste parte do presente documento, observam-se e identificam-se os \textit{code smells}. Estes inferem o grau de interpretabilidade do código fonte e, por isso, permitem avaliar se é ou não possível evoluir a versão atual do programa desenvolvido.

Neste caso, foi possível verificar a existência de \textbf{330 \textit{code smells}}. Apresentam-se de seguida o grau de severidade de cada um destes:
\begin{itemize}
    \item \textbf{\textit{info}}: 1 ocorrência (apenas faz-se referência à presença de um comentário \textit{TODO});
    \item \textbf{\textit{minor}}: 182 ocorrências;
    \item \textbf{\textit{major}}: 87 ocorrências;
    \item \textbf{\textit{critical}}: 50 ocorrências;
    \item \textbf{\textit{blocker}}: 10 ocorrências.
\end{itemize}

Comparativamente à versão número um, esta implementação possui, aproximadamente, 2,5 vezes mais \textit{code smells}, o que leva a concluir que esta, potencialmente, levará a uma interpretabilidade bastante pior.

Segundo a ferramenta \textit{SonarQube}, demoraria cerca de 6 dias a corrigir todos estes "defeitos". Este facto traduz aquilo a que chamamos o \textit{technical debt}, isto é, a probabilidade de ocorrências de erros no futuro. Esta ferramenta atribui a nota \textit{A} no que diz respeito ao \textit{technical debt}.

\subsubsection{Cobertura}
Quanto à cobertura não foram testados nenhuns aspetos intrínsecos a esta implementação.

\subsubsection{Duplicação de código}
No que diz respeito à duplicação de código existem 23 blocos repetidos em duas das classes implementadas, representando apenas 3,7\% do código total.

\section{Tarefa 2 - \textit{Refactoring}}
Nesta tarefa serão utilizadas ferramentas como o \textit{autorefactor}, \textit{IDEs} do \textit{Java} que suportam \textit{refactoring}, ou o \textit{jStanley} para identificar e eliminar os \textit{bad smells} e \textit{red smells} existentes no \textit{software} fornecido. Um estudo detalhado sobre os \textit{smells} encontrados na(s) aplicação(ões) fornecidas, os \textit{refactorings} aplicados e o \textit{technical debt} obtidos deverão ser incluídos no relatório.

\subsection{Versão 1 - \textit{demo1}}
Como foi referido anteriormente na secção 2.1.1, nesta versão foram observados vários problemas no código fonte.\\
Estes problemas estão divididos pelos seguintes tipos: \textit{Bug}, \textit{Vulnerability} e \textit{Code Smells}.\\\\
\underline{\textbf{Bugs}}
\begin{itemize}
    \item \textit{\textbf{blocker}}\\
        Foi observado o seguinte \textit{blocker bug}:\\
        \underline{Use try-with-resources or close this "ObjectOutputStream" in a "finally" clause.}\\ (Adicionar print)
        
        A classe \texttt{ObjectOutputStream} implementa a interface \texttt{AutoCloseable}, o que significa que é necessário fechá-la depois de a usar. Para isto, é recomendado que o objeto seja criado usando o padrão "\textit{try-with-resources}", pois vai ser fechado automaticamente.
        
        O \textit{IntelliJ} tem este refactoring implementado, logo a correção deste \textit{bug} é automática.
        
        (Adicionar print)
    
    \item \textit{\textbf{critical}}\\
        Foi observado o seguinte \textit{critical bug}:\\
        \underline{Save and re-use this "Random".}\\ (Adicionar print)
        
        Criar um objeto \texttt{Random} novo sempre que é necessário um valor aleatório é ineficiente e pode produzir números que não sejam completamente aleatórios. Para uma melhor eficiência e aleatoriedade, é preferível criar um único objeto \texttt{Random}, guardá-lo e reutilizá-lo.
        
        No \textit{Intellij}, podemos tranformar uma variável local numa variável de instância através do refactoring "\textit{Introduce Field...}", e de seguida, podemos usar o refactoring "\textit{move assignment to field declaration}".
        
        (Adicionar print)
        
    \item \textit{\textbf{major}}\\
        Foi observado o seguinte \textit{major bug}:\\
        \underline{Either override Object.equals(Object), or rename the method to prevent any confusion.}\\
        (Adicionar print)
        
        O nome de método \texttt{equals} deveria ser usado exclusivamente para sobrepor \texttt{Object.equals(Object)}.
        
        Usando o refactoring "\textit{Rename}" do \textit{IntelliJ} facilmente resolvemos este problema alterando o nome do método.
        
        (Adicionar print)
        
    \item \textit{\textbf{minor}}\\
        Foi observado o seguinte \textit{minor bug}:\\
        \underline{This class overrides "equals()" and should therefore also override "hashCode()".}\\
        (Adicionar Print)
        
        Se dois objetos são iguais de acordo com o método \texttt{equals(Object)}, então chamar o método \texttt{hashCode()} em ambos os objetos deve produzir resultados iguais.
        Para isto acontecer, ambos os métodos devem ser herdados ou sobrepostos.
        
        Para resolver este problema, o programador apenas necessita de escrever o nome do método \texttt{hashCode} e o \textit{IntelliJ} faz \textit{autocomplete} ao método.
        
        (Adicionar print)
\end{itemize}

\underline{\textbf{Vulnerability}}
\begin{itemize}
    \item \textit{\textbf{minor}}\\
    \underline{Use a logger to log this exception.}\\
    (Adicionar print)
    
    É recomendado a utilização de \textit{Loggers} para imprimir objetos da classe \texttt{Throwable}, pois estes normalmente contêm informação sensível que pode ser exposta.
    
    Nesta situação, o utilizador tem de fazer o refactoring manualmente, criando o \texttt{Logger} como uma variável estática da classe, e utilizando o método \texttt{log} para escrever a exceção num ficheiro \textit{log}.
\end{itemize}

\underline{\textbf{Code Smells}}
\begin{itemize}
    \item \textit{\textbf{Blocker}}\\
    \underline{Remove this "clone" implementation; use a copy constructor or copy factory instead.}\\
    (Adicionar Print)
    
    Acho que este não faz sentido mudar, porque eles utilizam estes métodos em streams
    
    \item \textit{\textbf{Critical}}\\
    \underline{Refactor this method to reduce its Cognitive Complexity from 112 to the 15 allowed.}\\
    (Adicionar print)
    
    Complexidade cognitiva é uma medida de dificuldade sobre o entendimento/compreensão do código. Maior complexidade cognitiva significa que muito provavelmente o programador irá ter uma maior dificuldade na manutenção do seu código.
    
    Neste caso, a maior parte complexidade cognitiva resulta da excessiva existência de cláusulas \textit{"catch"}.
    
    Uma solução para este problema utilizando o refactoring do \textit{IntelliJ}, é extrair estas partes do código para novos métodos.
    
    
    \item \textit{\textbf{Major}}\\
    
    \item \textit{\textbf{Minor}}\\
\end{itemize}


\subsection{Versão 2 - \textit{demo2}}

\section{Tarefa 3 - Teste da aplicação}
Nesta tarefa, tal como o nome da mesma transparece, serão utilizadas técnicas de teste de software para efectuar testes unitários em \textit{JUnit} e, ainda, o
teste de regressão da aplicação \textit{UmCarroJá}. Para além disso, serão utilizadas sistemas para a geração automática de casos de teste para gerar testes unitários e ainda inputs para simular a execução real da aplicação. De notar que nesta etapa também se procede à análise de testes unitários através da ferramenta \textit{JaCoCo}.

\subsection{Versão 1 - \textit{demo1}}

\subsubsection{Testes unitários - \textit{JUnit}}

Quanto à cobertura de testes, foi possível verificar que ...

\subsubsection{Geração automática de testes unitários - \textit{EvoSuite}}

Quanto à cobertura de testes, foi possível verificar que ...

\subsubsection{Geração automática de testes - \textit{QuickCheck}}
Nesta sub-tarefa foi-nos proposto gerar automaticamente ficheiros de \textit{logs} para testar a aplicação \textit{UmCarroJá}. Como seria de esperar, foi adoptada a utilização do sistema \textit{QuickCheck} para o efeito, tal como foi feito nas aulas.

A implementação do gerador pretendido segue, naturalmente, a estrutura apresentada pelo exemplo disponibilizado pelos docentes na página da disciplina. Como tal, foi necessário criar essencialmente 5 tipos de geradores, cada um com o seu tipo de dados:
\begin{itemize}
    \item \textit{NovoProp}: registo de um novo proprietário;
    \item \textit{NovoCliente}: registo de um novo cliente;
    \item \textit{NovoCarro}: registo de um novo carro;
    \item \textit{Aluguer}: registo de um aluguer efetuado por um cliente;
    \item \textit{Classificar}: classificação atribuída a um carro ou a um cliente/proprietário.
\end{itemize}

Também é preciso salientar que existe uma diversidade considerável de atributos associados a estes novos tipos (como por exemplo, \textit{emails}, nomes, marcas, moradas, entre outros). Por forma a garantir uma grande variedade de atributos, a maior parte dos geradores implementados utiliza o combinador \textit{frequency}. Este gerador associa a um determinado tipo de dados uma probabilidade de escolha. Consequentemente, foi possível gerar nomes, apelidos, moradas e marcas de automóveis de forma mais realista e em grande escala.

Por fim, de maneira a executar o gerador proposto, foi necessário parametrizar numa variável o número de registos a serem escritos para o ficheiro \textit{logs.bak} que irá armazenar toda esta informação. Desta forma, durante a execução da função \textbf{\textit{genLogsIO}} (responsável por gerar todos os registos dos tipos de dados mencionados anteriormente), é perguntado ao utilizador quantos registos pretende produzir.

\subsection{Versão 2 - \textit{demo2}}

\subsubsection{Testes unitários - \textit{JUnit}}

Quanto à cobertura de testes, foi possível verificar que ...

\subsubsection{Geração automática de testes unitários - \textit{EvoSuite}}

Quanto à cobertura de testes, foi possível verificar que ...

\subsubsection{Geração automática de testes - \textit{QuickCheck}}

\section{Tarefa 4 - Análise de desempenho}
\subsection{Versão 1 - \textit{demo1}}
\subsection{Versão 2 - \textit{demo2}}

\chapter{Conclusão}

\appendix
\chapter{Observações}
Durante a análise da primeira tarefa associada a este trabalho prático observaram-se, na ferramenta \textit{\textbf{Sonarqube}}, variados tipos de severidade de erros. Como tal, apresentam-se de seguida, de forma mais detalhada, os mesmos:
\begin{itemize}
    \item \textbf{\textit{minor}}:
    \\ Falha que afeta a qualidade do código e que pode ter um impacto minorativo na produtividade do programador: linhas de código longas, entre outros.
    \item \textbf{\textit{major}}:
    \\ Falha que afeta a qualidade do código e que pode ter um impacto significativo na produtividade do programador: blocos duplicados, parâmetros não utilizados, entre outros.
    \item \textbf{\textit{critical}}:
    \\ Erro com baixa probabilidade de afetar o comportamento da aplicação em produção ou um problema que representa uma falha de segurança. O código deve ser examinado imediatamente.
    \item \textbf{\textit{blocker}}:
    \\ Erro com alta probabilidade de afetar o comportamento da aplicação em produção. O código deve ser corrigido imediatamente.
\end{itemize}

\end{document}